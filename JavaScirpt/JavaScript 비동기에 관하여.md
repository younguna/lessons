# JavaScript 비동기에 관하여

## 이벤트 루프와 콜스택 그리고 태스크 큐
- setTimeout 그리고 Promise와 같은 비동기 로직들은 동기로 작동하는 다른 코드들과 다르게 작동하여 많은 개발자들을 당황케하고는 한다.
- 함수 a()와 b()가 있다고 가정한다.
- 함수 b는 내부에서 함수 a를 호출하고 `setTimeout(()=>{console.log("hi")}, 0)`를 실행한 뒤 `console.log("bye")`를 실행한다.
- 아래와 같을것이다.
```javascript
function a(){
    console.log("I am a");
}

function b(){
    a();
    setTimeout(()=>{
        console.log("hi");
    }, 0);
    console.log("bye");
}

b();
```
- 위의 코드는 어떤 순서로 작동할까?
- 우선적으로 함수 b가 콜스택에 올라간 후 a를 호출 하여 a가 콜스택에 올라갈 것이다.
- 함수 a가 `console.log("I am a")`를 실행한 후 콜스택에서 사라진 후 setTimeout은 브라우저 혹은 NodeJS에게 0초 뒤에 콜백함수를 실행하는 타이머 이벤트를 요청한 후 콜스택에서 바로 제거 된다.
- 0초 뒤에 콜백함수가 실행되어야 하지만 사실 콜백함수는 콜스택으로 가는 것이아니라 태스크큐라는 곳으로 가게되어 콜스택이 비워질때까지 기다려야 한다.
- `console.log("bye")`가 실행되고 함수 b까지 콜스택에서 사라지면 그때 계속해서 콜스택과 태스크큐를 점검하는 이벤트 루프가 태스크큐에서 `console.log("hi")`를 콜스택에 추가하고 실행한다.
- 정리하면 이렇다.
    - **콜스택**(**Call stack**)은 함수가 호출될때마다 내부에서 다른 함수를 호출하면 새로 호출된 함수들이 쌓이게 되고 새로 호출한 함수를 모두 실행하여 콜스택에서 제거하면 호출했던 코드로 돌아가 하던 실행을 마저하는 프로세스에서 실행중인 함수들이 호출된 역순으로 일을 마치는 순서를 말한다.
        - 기본적으로 나중에 호출된 함수가 먼저 실행되고 콜스택에서 제거된다.
    - **태스크큐**(**Task Queue**)는 자바스크립트에서 이벤트나 비동기 로직처럼 콜스택에서 순서대로 처리되는 것들이 아닌 이벤트 루프가 콜스택에 등록시켜 처리되야 하는 일들이 기다리는 곳이다.
        - 비동기 로직들은 콜스택이 모두비어질 때까지 이곳에서 기다린다.
    - **이벤트 루프**(**Event Loop**)는 계속해서 콜스택과 태스크큐를 점검하여 콜스택에 등록시킬 태스크들을 점검하고 등록하여 실행하는 역할을 수행한다.

## JavaScript는 기본적으로는 동기적이다.
- **기본적으로** 자바스크립트는 동기적이고 blocking을 사용하며, 싱글-쓰레드의 언어이다.
- 하지만 위의 특징은 절대로 다가 아니라는 점을 명심해야한다.
- 만약 자바스크립트가 매우 오래걸리는 Http요청을 했다면 그것을 계속해서 기다리기만 하는 것은 경험적으로 좋지 않은 결과를 가지게 될 것이다.
    - 그래서 자바스크립트 커뮤니티에서는 이런 부분에 대한 효과적인 대안책을 만들어 냈다.
- 사람들이 자바스크립트가 비동기적이라고 말하는 것은 사실은 **"자바스크립트가 비동기적으로 행동할 수 있게 조정할 수 있다"** 는 것이다.

## 비동기 콜백
- 위의 예에서 Http 요청을 보낸 후 응답을 기다리는 동안 나머지 코드들이 계속해서 실행 되도록 해주는 것이다.
- Http 응답이 도착했을때 그 응답은 태스크 큐로 들어가 이벤트 루프를 통해 프로세스된다.
- 이는 매우 좋은 해결책이지만 언제 이 태스크 큐로 들어간 Http응답이 처리될지 알 수 없다는 단점이 있다.
    - 그래서 개발자들은 그 응답을 가지고 처리하는 모든 로직을 코드 내부에 nest하는 식으로 해결하기도 한다.
    - 이는 코드가 매우 지저분해지며 그 유명한 "콜백지옥"이 바로 이 부분을 일컫는 것이다.
- 그리하여 Promise의 개념이 나타난다.

## Promise
- Promise는 관련로직을 한덩어리의 코드블록에 가두는 것이 아니라 따로 분리할 수 있게 해준다.
- 비동기 콜백을 전송하고 then으로 모든 관련로직을 잡아놓는다.
- 그리고 비동기 콜백이 돌아오면 관련로직을 불러다가 실행한다.
- 이는 비동기의 장점을 모두 이용하면서도 코드가 매우 모듈화되고 읽기 쉽게 해준다.